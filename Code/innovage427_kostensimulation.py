# -*- coding: utf-8 -*-
"""Innovage427-Kostensimulation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16fPuht2z1zLeHqu7Y6J7AWfMnFMHcAqk

# **Innovage Projekt 427**
## Kostensimulation zum Projekt "Psychotheraphie für Geflüchtete / ESTAIRconnect"
---
#### Comment:
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed eiusmod tempor incidunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquid ex ea commodi consequat. Quis aute iure reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint obcaecat cupiditat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum ...

<br>
+ Autor: Daniel Benninger (Innovage)

#### History:
- V2 19.10.25 - initial simulation, linegraphs / faked cost
- V1 15.10.25 - initial draft
---

### Setup Program / Load Libraries
"""

import pandas as pd
import numpy as np

import io

import matplotlib.pyplot as plt
import seaborn as sns

"""---
### Definiere Hilfsfunktionen zur Handhabung von Dataframes für Therapeuten, Patienten und Sitzungen (seesions)
"""

def InitDataFrame(AnzZeilen: int, Spalten: []) -> pd.DataFrame:
    """
    xxxxx

    Args:
        Spalten für das neue DataFrame  (bspw. TypA' und 'TypB').
        AnzZeilen des DataFrames
        Die Zellen werden per default mit Nullen (0) initialisiert

    Returns:
        pd.DataFrame: Das initialisierte DataFrame.
    """

    # Erstelle ein 2D-NumPy-Array mit Anzahl Zeilen und Typ A/B Spalten, gefüllt mit Nullen
    daten = np.zeros((AnzZeilen, len(Spalten)))

    # Erstelle das Therapeut DataFrame aus dem NumPy-Array
    dfNew = pd.DataFrame(data=daten, columns=Spalten)

    return dfNew

def AddTherapeut(dfTherapeut: pd.DataFrame, AnzNeu: int, Typ: str, StartWeek: int) -> pd.DataFrame:
    """
    Inkrementiert die Werte in der Spalte Typ  des DataFrames
    dfTherapeut ab dem Index (StartWeek - 1) bis zum Ende des DataFrames
    um den Wert AnzNeu.

    Args:
        dfTherapeut (pd.DataFrame): Das DataFrame mit den Spalten 'TypA' und 'TypB'.
        AnzNeu (int): Der Wert, um den die Zellen inkrementiert werden.
        StartWeek (int): Die Startwoche (entspricht dem Index StartWeek - 1).

    Returns:
        pd.DataFrame: Das aktualisierte DataFrame.
    """

    # 1. Start-Index berechnen
    start_index = StartWeek - 1

    # 2. End-Index bestimmen
    end_index = dfTherapeut.index.max()

    # Prüfen, ob der Start-Index innerhalb der Grenzen des DataFrames liegt
    if start_index > end_index or start_index < 0:
        print(f"⚠️ Warnung: StartWeek ({StartWeek}) liegt außerhalb des gültigen Indexbereichs (1 bis {end_index + 1}). Es wurden keine Änderungen vorgenommen.")
        return dfTherapeut

    # 3. Den relevanten Bereich auswählen
    # Wir verwenden .loc, um Zeilen (ab start_index) auszuwählen
    # Inkrementiere die Werte in Spalte Typ
    dfTherapeut.loc[start_index:, Typ] += AnzNeu

    return dfTherapeut

def DelTherapeut(dfTherapeut: pd.DataFrame, AnzDel: int, Typ: str, StartWeek: int) -> pd.DataFrame:
    """
    Dekrementiert die Werte in den Spalten Typ des DataFrames
    dfTherapeut ab dem Index (StartWeek - 1) bis zum Ende des DataFrames
    um den Wert AnzNeu.

    Args:
        dfTherapeut (pd.DataFrame): Das DataFrame mit den Spalten 'TypA' und 'TypB'.
        AnzNeu (int): Der Wert, um den die Zellen dekrementiert werden.
        StartWeek (int): Die Startwoche (entspricht dem Index StartWeek - 1).

    Returns:
        pd.DataFrame: Das aktualisierte DataFrame.
    """

    # 1. Start-Index berechnen
    start_index = StartWeek - 1

    # 2. End-Index bestimmen
    end_index = dfTherapeut.index.max()

    # Prüfen, ob der Start-Index innerhalb der Grenzen des DataFrames liegt
    if start_index > end_index or start_index < 0:
        print(f"⚠️ Warnung: StartWeek ({StartWeek}) liegt außerhalb des gültigen Indexbereichs (1 bis {end_index + 1}). Es wurden keine Änderungen vorgenommen.")
        return dfTherapeut

    # 3. Den relevanten Bereich auswählen
    # Wir verwenden .loc, um sowohl Zeilen (ab start_index) als auch die Spalten ('TypA', 'TypB') auszuwählen.

    # Inkrementiere die Werte in Spalte Typ
    dfTherapeut.loc[start_index:, Typ] -= AnzDel

    return dfTherapeut

def AddPatient(dfPatient: pd.DataFrame, AnzNeu: float, Typ: str, StartWeek: int) -> pd.DataFrame:
    """
    Inkrementiert die Werte in der Spalte Typ  des DataFrames
    dfPatient ab dem Index (StartWeek - 1) bis zum Ende des DataFrames
    um den Wert AnzNeu.

    Args:
        dfPatient (pd.DataFrame): Das DataFrame mit den Spalten 'TypA' und 'TypB'.
        AnzNeu (int): Der Wert, um den die Zellen inkrementiert werden.
        StartWeek (int): Die Startwoche (entspricht dem Index StartWeek - 1).

    Returns:
        pd.DataFrame: Das aktualisierte DataFrame.
    """

    # 1. Start-Index berechnen
    start_index = StartWeek - 1

    # 2. End-Index bestimmen
    end_index = dfPatient.index.max()

    # Prüfen, ob der Start-Index innerhalb der Grenzen des DataFrames liegt
    if start_index > end_index or start_index < 0:
        print(f"⚠️ Warnung: StartWeek ({StartWeek}) liegt außerhalb des gültigen Indexbereichs (1 bis {end_index + 1}). Es wurden keine Änderungen vorgenommen.")
        return dfPatient

    # 3. Den relevanten Bereich auswählen
    # Wir verwenden .loc, um Zeilen (ab start_index) auszuwählen
    # Inkrementiere die Werte in Spalte Typ
    dfPatient.loc[start_index:, Typ] += AnzNeu

    return dfPatient

def DelPatient(dfPatient: pd.DataFrame, AnzDel: float, Typ: str, StartWeek: int) -> pd.DataFrame:
    """
    Dekrementiert die Werte in den Spalten Typ des DataFrames
    dfPatient ab dem Index (StartWeek - 1) bis zum Ende des DataFrames
    um den Wert AnzNeu.

    Args:
        dfPatient (pd.DataFrame): Das DataFrame mit den Spalten 'TypA' und 'TypB'.
        AnzNeu (int): Der Wert, um den die Zellen dekrementiert werden.
        StartWeek (int): Die Startwoche (entspricht dem Index StartWeek - 1).

    Returns:
        pd.DataFrame: Das aktualisierte DataFrame.
    """

    # 1. Start-Index berechnen
    start_index = StartWeek - 1

    # 2. End-Index bestimmen
    end_index = dfPatient.index.max()

    # Prüfen, ob der Start-Index innerhalb der Grenzen des DataFrames liegt
    if start_index > end_index or start_index < 0:
        print(f"⚠️ Warnung: StartWeek ({StartWeek}) liegt außerhalb des gültigen Indexbereichs (1 bis {end_index + 1}). Es wurden keine Änderungen vorgenommen.")
        return dfTherapeut

    # 3. Den relevanten Bereich auswählen
    # Wir verwenden .loc, um sowohl Zeilen (ab start_index) als auch die Spalten ('TypA', 'TypB') auszuwählen.

    # Inkrementiere die Werte in Spalte Typ
    dfPatient.loc[start_index:, Typ] -= AnzDel

    return dfPatient

def AddSession (dfSession: pd.DataFrame, AnzNeu: int, Typ: str, StartWeek: int) -> pd.DataFrame:
    """
    Inkrementiert die Werte in der Spalte Typ  des DataFrames
    dfSession ab dem Index (StartWeek - 1) bis zum Ende des DataFrames
    um den Wert AnzNeu.

    Args:
        dfSession (pd.DataFrame): Das DataFrame mit den Spalten 'TypA' und 'TypB'.
        AnzNeu (int): Der Wert, um den die Zellen inkrementiert werden.
        StartWeek (int): Die Startwoche (entspricht dem Index StartWeek - 1).

    Returns:
        pd.DataFrame: Das aktualisierte DataFrame.
    """

    # 1. Start-Index berechnen
    start_index = StartWeek - 1

    # 2. End-Index bestimmen
    end_index = dfSession.index.max()

    # Prüfen, ob der Start-Index innerhalb der Grenzen des DataFrames liegt
    if start_index > end_index or start_index < 0:
        print(f"⚠️ Warnung: StartWeek ({StartWeek}) liegt außerhalb des gültigen Indexbereichs (1 bis {end_index + 1}). Es wurden keine Änderungen vorgenommen.")
        return dfSession

    # 3. Den relevanten Bereich auswählen
    # Wir verwenden .loc, um Zeilen (ab start_index) auszuwählen
    # Inkrementiere die Werte in Spalte Typ
    dfSession.loc[start_index:, Typ] += AnzNeu

    return dfSession

def Add_Zero_Columns(df: pd.DataFrame, new_columns: list) -> pd.DataFrame:
    """
    Erweitert ein bestehendes DataFrame um die in new_columns angegebenen Spalten
    und initialisiert deren Werte mit Nullen.

    Args:
        df (pd.DataFrame): Das zu erweiternde DataFrame.
        new_columns (list): Eine Liste der Namen der neuen Spalten.

    Returns:
        pd.DataFrame: Das erweiterte DataFrame.
    """

    # 1. Die Länge des DataFrames (Anzahl der Zeilen, m) bestimmen
    num_rows = len(df)

    # 2. Iteriere über die Liste der neuen Spaltennamen
    for col_name in new_columns:
        # Füge die neue Spalte hinzu und initialisiere sie mit Nullen.
        # Da NumPy-Arrays effizienter sind, verwenden wir np.zeros,
        # um ein Array der Länge m (num_rows) zu erstellen.
        df[col_name] = np.zeros(num_rows)

    return df

spalten = ["Total"]
anzahl_zeilen = 104
# Erstelle das initiale Session DataFrame, mit der Totalisierungsspalte an erster Stelle
dfSession = InitDataFrame(anzahl_zeilen, spalten)

# print(dfSession)

def Add_Session_Columns(df: pd.DataFrame, AnzNew: int, StartWeek: int, MaxSession: int) -> pd.DataFrame:
    """
    Erweitert ein bestehendes DataFrame um AnzNew Spalten mit Nullen
    und initialisiert die neuen Session Spalten mit (max AnzSession) Einsen ab der Position StartWeek.

    Args:
        df (pd.DataFrame): Das zu erweiternde DataFrame.
        AnzNew (int): Die Anzahl der neuen Spalten.
        StartWeek (int): Die Startwoche der neuen Session Spalten.
        MaxSession (int): Die maximale Anzahl an Sessions proPatient

    Returns:
        pd.DataFrame: Das erweiterte DataFrame.
    """

    anzahl_sessions = MaxSession
    anzahl_spalten = AnzNew

    start_index = StartWeek
    end_index = start_index + anzahl_sessions - 1

    if end_index > len(df):
        end_index = len(df)

    for i in range(1, anzahl_spalten+1):
        spalten_name = str(StartWeek) + "_" + str(i)
        df = Add_Zero_Columns(df, [spalten_name])
        df.loc[start_index:end_index, spalten_name] = 1

    return df

dfX = Add_Session_Columns(dfSession, AnzNew=3, StartWeek=11, MaxSession=35)
print(dfX)

dfX['Total'] = dfX.drop(columns=['Total']).sum(axis=1)
# print(dfX)

dfX = Add_Session_Columns(dfX, AnzNew=5, StartWeek=3, MaxSession=35)
dfX['Total'] = dfX.drop(columns=['Total']).sum(axis=1)
print(dfX)

"""---  
## Simulation Parameter and Tools
"""

# Definiere die Anzahl der Wochen (als Zeitreihe der Simulation)
anzahl_zeilen = 104          # Anzahl Wochen für die Simulation

# Definiere die Spaltennamen
spaltenAB = ["TypA", "TypB"]  # Typen der Therapeuten (Varianten für die Kostensimulation)

# Erstelle das Therapeut DataFrame
dfTherapeut = InitDataFrame(anzahl_zeilen, spaltenAB)

# Erstelle das Patient DataFrame
dfPatient = InitDataFrame(anzahl_zeilen, spaltenAB)

# Erstelle das Cost DataFrame
dfCost = InitDataFrame(anzahl_zeilen, spaltenAB)

# Erstelle das Income DataFrame
dfIncome = InitDataFrame(anzahl_zeilen, spaltenAB)

spaltenTot = ["Total"]

# Erstelle das initiale Session DataFrame, mit der Totalisierungsspalte an erster Stelle
dfSessionA = InitDataFrame(anzahl_zeilen, spaltenTot)
dfSessionB = InitDataFrame(anzahl_zeilen, spaltenTot)

"""
## Simulation Szenario(s)"""

def Config_Therapeut_or_Patient (dfOp: pd.DataFrame, dfToP: pd.DataFrame) -> pd.DataFrame:
    """
    Geht jede Zeile des Operations-DataFrames durch und aktualisiert dfToP (Therapeut or Patient) entsprechend.

    Args:
        dfOp  (pd.DataFrame): DataFrame mit den Operationen.
        dfToP (pd.DataFrame): DataFrame, das aktualisiert werden soll.

    Returns:
        pd.DataFrame: Aktualisiertes DataFrame
    """

    print(f"Starte Abarbeitung von {len(dfOp)} Operationen auf dfTherapeut (Länge: {len(dfTherapeut)}).")

    # Durchlaufe jede Zeile von dfOp
    for index, row in dfOp.iterrows():
        typ    = row['Typ']
        op     = row['Op']
        anzahl = row['Anzahl']
        week   = row['Week']

        # Bestimme die Zielspalte in dfTherapeut
        # Angenommen, Typ A -> Spalte TypA, Typ B -> Spalte TypB, etc.
        column = f"Typ{typ}"

        print(f"\n-> Verarbeite Zeile {index} (Typ: {typ}, Op: {op}, Anzahl: {anzahl}, Week: {week}):")

        if column not in dfToP.columns:
            print(f"   Fehler: Zielspalte {column} existiert nicht in dfTherapeut.")
            continue

        # Rufe die passende funktion (ADD or DEL) zum Therapeut dataframe auf
        if op == "ADD":
          dfToP  = AddTherapeut(dfToP, anzahl, column, week)
        if op == "DEL":
          dfToP  = DelTherapeut(dfToP, anzahl, column, week)
        #update_dataframe_value(dfTherapeut, week, target_column, anzahl, op)
        #print(f"   {target_column} von Week {week} ({week-1}) bis zum Ende um {anzahl} {op}iert.")

    return dfToP

def Config_Sessions (dfOp: pd.DataFrame, dfSession: pd.DataFrame, typAB: str) -> pd.DataFrame:
    """
    Geht jede Zeile des Operations-DataFrames durch und aktualisiert dfToP (Therapeut or Patient) entsprechend.

    Args:
        dfOp  (pd.DataFrame): DataFrame mit den Operationen.
        dfSession (pd.DataFrame): DataFrame, das aktualisiert werden soll.
        typ (str): Typ des Therapeuten (A oder B)

    Returns:
        pd.DataFrame: Aktualisiertes DataFrame
    """

    print(f"Starte Abarbeitung von {len(dfOp)} Operationen auf dfSession (Länge: {len(dfSession)}).")

    # Durchlaufe jede Zeile von dfOp
    for index, row in dfOp.iterrows():
        typ    = row['Typ']
        op     = row['Op']
        anzahl = row['Anzahl']
        week   = row['Week']


        # Verabeite die Parameter gemäss passendem typ
        if typ == typAB and op == "ADD":
          print(f"\n-> Verarbeite Zeile {index} (Typ: {typ}, Op: {op}, Anzahl: {anzahl}, Week: {week}):")
          dfSession = Add_Session_Columns(dfSession, AnzNew=anzahl, StartWeek=week, MaxSession=35)

    return dfSession

# 1. Definiere die komma-separierten Daten als String
# Die erste Zeile enthält die Spaltennamen
csv_data = """Typ,Op,Anzahl,Week
A,ADD,3,2
A,ADD,5,11
B,ADD,5,11
A,DEL,2,35
B,ADD,3,21
B,ADD,5,30
B,DEL,3,25
"""

# 2. Verwende io.StringIO, um den String wie eine Datei zu behandeln
# Dies erlaubt pd.read_csv, die Daten direkt aus dem Speicher zu lesen.
dfSzenarioT = pd.read_csv(io.StringIO(csv_data))

print("--- Initialisiertes DataFrame aus CSV-String ---")
print(dfSzenarioT)

# 1. Definiere die komma-separierten Daten als String
# Die erste Zeile enthält die Spaltennamen
csv_data = """Typ,Op,Anzahl,Week
A,ADD,3,5
A,ADD,5,7
B,ADD,5,6
B,ADD,7,21
B,ADD,5,30
A,ADD,7,35
A,ADD,5,55
"""

# 2. Verwende io.StringIO, um den String wie eine Datei zu behandeln
# Dies erlaubt pd.read_csv, die Daten direkt aus dem Speicher zu lesen.
dfSzenarioP = pd.read_csv(io.StringIO(csv_data))

print("--- Initialisiertes DataFrame aus CSV-String ---")
print(dfSzenarioP)

dfSessionA.head()
#dfSessionA.shape

# Define the file path and sheet name
excel_file      = '427-Kostensimuation-Szenarien.xlsx'  # actual Excel file path
sheet_therapeut = 'Therapeut'                           # actual sheet name
sheet_patient   = 'Patient'

# Read the Excel file into a DataFrame, specifying column data types
dfSzenarioT = pd.read_excel(
    excel_file,
    sheet_name=sheet_therapeut,
    dtype={'Typ': str, 'Op': str, 'Anzahl': int, 'Week': int}
)

dfSzenarioP = pd.read_excel(
    excel_file,
    sheet_name=sheet_patient,
    dtype={'Typ': str, 'Op': str, 'Anzahl': int, 'Week': int}
)

print("--- Initialized DataFrame from Excel file ---")
print(dfSzenarioT)
print(dfSzenarioP)

dfSAx = Config_Sessions(dfSzenarioP, dfSessionA, "A")
dfSBx = Config_Sessions(dfSzenarioP, dfSessionB, "B")

dfSAx['Total'] = dfSAx.drop(columns=['Total']).sum(axis=1)
dfSAx.head(20)

dfSBx['Total'] = dfSBx.drop(columns=['Total']).sum(axis=1)
dfSBx.head(20)

dfTx = Config_Therapeut_or_Patient(dfSzenarioT, dfTherapeut)
dfPx = Config_Therapeut_or_Patient(dfSzenarioP, dfPatient)

dfSAx.head(20)

"""---  
## Visualizations

Linegraphs of Therapeuts, Patients and Sessions (over the week series)
"""

def Plot_LineGraph_of_Dataframe(df: pd.DataFrame, title: str, xlabel: str, ylabel: str) -> plt.Figure:
  # Plot a line graph of Sessions with all columns
  df.plot(kind='line', linestyle='--', figsize=(15, 5), )

  # Set the number of ticks for the x-axis
  plt.locator_params(axis='x', nbins=7)
  plt.locator_params(axis='y', nbins=5)

  # Add title and labels
  plt.title(title)
  plt.xlabel(xlabel)
  plt.ylabel(ylabel)

  # Return the figure object instead of showing it
  # return ax.figure
  plt.show()

Plot_LineGraph_of_Dataframe(dfTx, "Line Graph of Therapeuts", "WeekNo", "No of active Therapeuts per Week")

Plot_LineGraph_of_Dataframe(dfPx, "Line Graph of Patients", "WeekNo", "No of active Patients per Week")

Plot_LineGraph_of_Dataframe(dfSAx, "Line Graph of Sessions A", "WeekNo", "No of Total Sessions (Typ A) per Week")

Plot_LineGraph_of_Dataframe(dfSBx, "Line Graph of Sessions B", "WeekNo", "No of Total Sessions (Typ B) per Week")

dfCost = InitDataFrame(anzahl_zeilen, spaltenAB)

dfCost['TypA'] = dfSAx['Total'] * -155
dfCost['TypB'] = dfSBx['Total'] * 85
# dfCost.head(20)

# dfCost['TypACum'] = dfCost['TypA'].cumsum()
# dfCost['TypBCum'] = dfCost['TypB'].cumsum()
dfCost['Total'] = dfCost['TypA'] + dfCost['TypB']
dfCost['TotalCum'] = dfCost['TypA'].cumsum() + dfCost['TypB'].cumsum()

# dfCost.head(20)

Plot_LineGraph_of_Dataframe(dfCost[['Total','TypA','TypB']], "Line Graph of Session Cost", "WeekNo", "Session Costs (CHF) per Week")

import matplotlib.pyplot as plt
# Create a 2x2 grid of plots
fig, axes = plt.subplots(2, 2, figsize=(12, 8))

# Plot dfTx on the first subplot
dfTx.plot(ax=axes[0, 0], kind='line', linestyle='--')
axes[0, 0].set_title("Line Graph of Therapeuts")
axes[0, 0].set_xlabel('WeekNo')
axes[0, 0].set_ylabel('No of active Therapeuts per Week')
axes[0, 0].locator_params(axis='x', nbins=10)
axes[0, 0].locator_params(axis='y', nbins=5)


# Plot dfPx on the second subplot
dfPx.plot(ax=axes[0, 1], kind='line', linestyle='--')
axes[0, 1].set_title('Line Graph of Patients')
axes[0, 1].set_xlabel('WeekNo')
axes[0, 1].set_ylabel('No of active Patients per Week')
axes[0, 1].locator_params(axis='x', nbins=10)
axes[0, 1].locator_params(axis='y', nbins=5)


# Plot dfSAx on the third subplot
dfSAx['Total'].plot(ax=axes[1, 0], kind='line', linestyle='--')
axes[1, 0].set_title('Line Graph of Sessions A')
axes[1, 0].set_xlabel('WeekNo')
axes[1, 0].set_ylabel('No of Total Sessions (Typ A) per Week')
axes[1, 0].locator_params(axis='x', nbins=10)
axes[1, 0].locator_params(axis='y', nbins=5)


# Plot dfSBx on the fourth subplot
dfSBx['Total'].plot(ax=axes[1, 1], kind='line', linestyle='--', color='orange')
axes[1, 1].set_title('Line Graph of Sessions B')
axes[1, 1].set_xlabel('WeekNo')
axes[1, 1].set_ylabel('No of Total Sessions (Typ B) per Week')
axes[1, 1].locator_params(axis='x', nbins=10)
axes[1, 1].locator_params(axis='y', nbins=5)

# Adjust layout to prevent overlap
plt.tight_layout()

# Show the plot
plt.show()

Plot_LineGraph_of_Dataframe(dfCost[['TypA','TypB','Total']], "Line Graph of Session Cost", "WeekNo", "Session Costs (CHF) per Week")

"""---
---
## Dashboard Style Visualization

---
### **OLD CODE - WORK IN PROGRESS**
---
"""